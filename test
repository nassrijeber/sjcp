import org.apache.poi.util.ReplacingInputStream;

import java.io.*;
import java.nio.file.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

public final class ZipExtractor {

    private static final int BUFFER_SIZE = 64 * 1024;
    private static final long MAX_UNCOMPRESSED_SIZE = 200L * 1024 * 1024 * 1024; // 200 Go si besoin

    private ZipExtractor() {}

    /**
     * Extrait UNE SEULE entrée d'un ZIP dont le nom contient nameFragment.
     * Le contenu est extrait en streaming et éventuellement normalisé (lineSeparator → "\n").
     *
     * @param zipStream InputStream du ZIP (S3, fichier local, etc.)
     * @param nameFragment chaîne à chercher dans le nom d'une entrée
     * @param lineSeparator séparateur logique (ex "#@@#") ou null si déjà "\n"
     * @param targetDir répertoire cible
     * @return chemin du fichier extrait
     */
    public static String extractSingleFile(InputStream zipStream,
                                           String nameFragment,
                                           String lineSeparator,
                                           Path targetDir) throws IOException {

        boolean normalize = lineSeparator != null && lineSeparator.length() > 1;

        try (ZipInputStream zis = new ZipInputStream(zipStream)) {
            ZipEntry entry;

            while ((entry = zis.getNextEntry()) != null) {

                if (entry.isDirectory()) continue;

                String entryName = Paths.get(entry.getName())
                                        .getFileName()
                                        .toString();

                // On garde seulement le fichier recherché
                if (!entryName.contains(nameFragment)) {
                    continue;
                }

                Path outPath = targetDir.resolve(entryName);

                // Normalisation éventuelle du line separator "#@@#" → "\n"
                InputStream in = normalize
                        ? new ReplacingInputStream(zis, lineSeparator, "\n")
                        : zis;

                try (OutputStream out = Files.newOutputStream(
                        outPath,
                        StandardOpenOption.CREATE,
                        StandardOpenOption.TRUNCATE_EXISTING)) {

                    byte[] buffer = new byte[BUFFER_SIZE];
                    long total = 0L;
                    int n;

                    while ((n = in.read(buffer)) != -1) {
                        total += n;
                        if (total > MAX_UNCOMPRESSED_SIZE) {
                            throw new IOException(
                                    "Uncompressed size too large for entry " + entryName);
                        }
                        out.write(buffer, 0, n);
                    }
                }

                return outPath.toString();  // on retourne dès qu’on a extrait UNE entrée
            }
        }

        throw new FileNotFoundException(
                "No entry containing '" + nameFragment + "' found in zip");
    }
}Path tmpDir = Paths.get(System.getProperty("java.io.tmpdir"));

try (InputStream zipStream = s3Client.getObject(bucket, key).getObjectContent()) {

    // On extrait uniquement RADAR_HEADER (exact ou partiel)
    String headerPath = ZipExtractor.extractSingleFile(
            zipStream,
            "RADAR_HEADER",         // nom partiel ou exact
            "#@@#",                 // line separator à normaliser, sinon null
            tmpDir
    );

    Dataset<Row> headerDf = spark.read()
            .options(toCsvOptionsHeader())
            .schema(headerSchema)
            .csv(headerPath);
}